# Iot-Cpp-2025
IoT 개발자 C++기초 프로그래밍 언어 리포지토리

## 1일차
- C++ 이란 ?
    - 덴마크의 컴퓨터 과학자 비야네 스트로스트룹(Bjarne Stroustrup)가 C언어를 바탕으로 제작
    - 객체지향 프로그래밍 언어 (Object Oriented Program)
    - 고성능과 메모리 제어가 가능하여 게임, 시스템 프로그래밍, 임베디드 개발 등에 널리 사용
- 화면 입출력
    - c언어의 입출력처럼 따로 서식을 지정할 필요 없음.
    - 데이터의 구분은 스페이스, 엔터, 탭과 같은 공백을 통해 이루어짐
    - `std::cout<<출력대상<<출력대상;`
    - `std::cin >> 변수 `
    - `std::endl` - 개행
- 함수오버로딩(Function Overloading)
    - 함수호출 시 **함수의 이름**과 **전달되는 인자의 정보**를 동시에 참조하여 호출할 함수 결정.
    - 즉, 매개변수의 선언이 다르면 동일한 함수도 정의 가능
        1. 매개변수의 자료형이 다른 경우
        2. 매개벼수의 수가 다른 경우
        반환형만 다른 경우는 오버로딩의 조건 만족 x
- 매개변수의 디폴트 값
    - 디폴트 값의 정보는 함수의 선언에 위치
    - 왼쪽에서 부터 인자가 전달되므로 디폴트 값은 오른쪽에서 부터 채워야 함
    - c언어에는 매개변수에 디폴트 값을 지정할 수 없음
- 인라인 함수
    - c의 매크로 함수와 동일 기능
    - 매크로 함수의 장점을 취하고 단점을 보완한 것
    - ※ 매크로 함수
        - 컴파일 이전 선행처리기에서 처리됨
        - 장점: 함수가 인라인화 되어 성능의 향상으로 이어질 수 있음 (스택할당, 반환 과정 생략)
        - 단점: 함수의 정의 방식이 일반함수에 비해 복잡
        디버깅 어려움
    
    - **컴파일러**에 의해서 처리됨.
    - 컴파일러가 함수의 인라인화를 결정한다
    - inline 선언이 되어도 인라인처리 되지 않을 수있고, lnline이 없어도 인라인처리 될 수 있다.
    - 자료형에 독립적이지 못함. (템플릿으로 보완가능)

- namespace
    - 같은 이름의 변수나 함수를 구별할 수 있도록 특정 범위를 지정하는 역할
    - 이름 충돌을 방지하고 코드의 구조화에 도움을 줌. (라이브러리나 대규모 프로젝트에서 사용)
    - `::`(범위 지정 연산자)를 사용하여 네임스페이스 내부 요소에 접근 가능. (전역변수 접근 ⭕) 
        - `std::cout`, `std::endl`
    - `using` 키워드를 사용하면 네임스페이스를 명시하지 않고도 내부 요소를 직접 사용가능
    - C++17부터 namespace A::B처럼 축약된 중첩 네임스페이스 사용 가능.
    - 익명 네임스페이스는 파일 내부에서만 접근 가능하도록 제한할 때 유용.
    
- bool 자료형
    - 일반적으로 0은 거짓, 1은 참을 의미하는 정수
    ```c
    #define True 1
    #define False 0
    ```
    - C++ 에서도 위와 같은 방법이 사용되지만, `true`, `false` 키워드 사용가능 (새로운 C표준에서도)
    - `bool` 자료형 존재
- new/delete
    - C++에서 동적 메모리 할당과 해제를 위해 사용됨.
    - 각각 C 언어의 malloc/free 와 대응
    - 할당된 메모리는 힙(Heap) 영역에 존재
    - `new`는 메모리 할당 후 해당 메모리의 주소를 반환.
    - `delete`로 할당된 메모리를 해제할 때 사용
    ```CPP
    int* ptr = new int;  // int형 메모리 할당
    *ptr = 10;  // 값 저장
    delete ptr; // 메모리 해제

    int* arr = new int[5];  // 정수형 배열 5개 동적 할당
    delete[] arr;  // 배열 해제 (배열일 경우 delete 뒤에 `[]` 필요)

    ```
    
- 참조자(Reference)
    - 할당된 메모리 공간(변수)에 별명을 붙이는 것
    - `&`연산자 사용
        - 선언된 변수의 앞: **주소 연산자**
        - 새로 선언되는 변수 앞: **참조자 선언**
    - 선언 가능 범위
        - 여러 개의 참조자 선언 가능
        - 참조자를 대상으로 참조자 선언 가능
        - 변수에 대해서만 선언 가능 (포인터 변수도 o)
        - 선언과 동시에 변수를 참조해야 함
        - NULL 초기화 불가
        - 참조의 대상 바꿀 수 없음
    - call-by-reference
        - 주소 값이용 call-by-reference
        - 참조자 이용 call-by-reference
        - 함수 내에서 참조자를 통한 값의 변경 진행하지 않을 경우, `const` 선언 해주기
    
    - reference 함수
        - 반환형이 참조형인 경우
        ```C
        int num2 = RefRetFuncOne(num1); ✅
        int &num2 = RefRetFuncOne(num1); ✅
        ```
        - 반환형이 기본자료형인 경우
        ```C
        int num2 = RefRetFuncOne(num1); ✅
        int &num2 = RefRetFuncOne(num1); ⛔
        ```
        - 단점  

            ✔ 함수의 정의형태와 함수의 호출형태를 봐도 값의 변경유무를 알 수 없다. 함수의 몸체 형태를 확인해야됨.  

            ✔ c 언어에서는 함수의 호출형태만 보고 알 수 있었음  

            ✔ 단점을 보완하고자 **const 참조자**를 사용
        - ⚠ 주의 ⚠ 지역변수를 참조로 반환하면 **절대 안됨** (컴파일 에러 없음)
    - const 참조자
        `void Func(const int &ref) {. . . }`
        함수 Func 내에서 참조자 ref로 값의 참조는 가능하지만 값의 변경은 허용하지 않겠다는 의미  
        `int &num = 10`
        const 를 붙이면 변수뿐만 아니라 상수도 참조 가능하다 (임시변수)
        - 함수의 원형 선언만 봐도 값의 변경이 일어나지 않음을 판단 가능
        - 실수로 인한 값의 변경이 일어나지 않음
        - 상수 매개변수를 받을 수 있음

- 구조체  
    여러 개의 변수를 하나로 묶어 관리할 수 있는 **사용자 정의 자료형**  
    클래스와 거의 동일하지만 기본 접근 지정자 **public**
    C와는 달리 **멤버 함수**를 가질 수 있음




- Question    
    - [Q1. void SwapRef(int &ref1, int &ref2) 선언만 했는데?](Question.md/#q1-void-swaprefint-ref1-int-ref2-선언만-했는데)