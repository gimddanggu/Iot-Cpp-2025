# Iot-Cpp-2025
IoT 개발자 C++기초 프로그래밍 언어 리포지토리

## 1일차
- C++ 이란 ?
    - 덴마크의 컴퓨터 과학자 비야네 스트로스트룹(Bjarne Stroustrup)가 C언어를 바탕으로 제작
    - 객체지향 프로그래밍 언어 (Object Oriented Program)
    - 고성능과 메모리 제어가 가능하여 게임, 시스템 프로그래밍, 임베디드 개발 등에 널리 사용
- 화면 입출력
    - c언어의 입출력처럼 따로 서식을 지정할 필요 없음.
    - 데이터의 구분은 스페이스, 엔터, 탭과 같은 공백을 통해 이루어짐
    - `std::cout<<출력대상<<출력대상;`
    - `std::cin >> 변수 `
    - `std::endl` - 개행
- 함수오버로딩(Function Overloading)
    - 함수호출 시 **함수의 이름**과 **전달되는 인자의 정보**를 동시에 참조하여 호출할 함수 결정.
    - 즉, 매개변수의 선언이 다르면 동일한 함수도 정의 가능
        1. 매개변수의 자료형이 다른 경우
        2. 매개벼수의 수가 다른 경우
        반환형만 다른 경우는 오버로딩의 조건 만족 x
- 매개변수의 디폴트 값
    - 디폴트 값의 정보는 함수의 선언에 위치
    - 왼쪽에서 부터 인자가 전달되므로 디폴트 값은 오른쪽에서 부터 채워야 함
    - c언어에는 매개변수에 디폴트 값을 지정할 수 없음
- 인라인 함수
    - c의 매크로 함수와 동일 기능
    - 매크로 함수의 장점을 취하고 단점을 보완한 것
    - ※ 매크로 함수
        - 컴파일 이전 선행처리기에서 처리됨
        - 장점: 함수가 인라인화 되어 성능의 향상으로 이어질 수 있음 (스택할당, 반환 과정 생략)
        - 단점: 함수의 정의 방식이 일반함수에 비해 복잡
        디버깅 어려움
    
    - **컴파일러**에 의해서 처리됨.
    - 컴파일러가 함수의 인라인화를 결정한다
    - inline 선언이 되어도 인라인처리 되지 않을 수있고, lnline이 없어도 인라인처리 될 수 있다.
    - 자료형에 독립적이지 못함. (템플릿으로 보완가능)

- namespace
    - 같은 이름의 변수나 함수를 구별할 수 있도록 특정 범위를 지정하는 역할
    - 이름 충돌을 방지하고 코드의 구조화에 도움을 줌. (라이브러리나 대규모 프로젝트에서 사용)
    - `::`(범위 지정 연산자)를 사용하여 네임스페이스 내부 요소에 접근 가능. (전역변수 접근 ⭕) 
        - `std::cout`, `std::endl`
    - `using` 키워드를 사용하면 네임스페이스를 명시하지 않고도 내부 요소를 직접 사용가능
    - C++17부터 namespace A::B처럼 축약된 중첩 네임스페이스 사용 가능.
    - 익명 네임스페이스는 파일 내부에서만 접근 가능하도록 제한할 때 유용.
    
- bool 자료형
    - 일반적으로 0은 거짓, 1은 참을 의미하는 정수
    ```c
    #define True 1
    #define False 0
    ```
    - C++ 에서도 위와 같은 방법이 사용되지만, `true`, `false` 키워드 사용가능 (새로운 C표준에서도)
    - `bool` 자료형 존재
- new/delete
    - C++에서 동적 메모리 할당과 해제를 위해 사용됨.
    - 각각 C 언어의 malloc/free 와 대응
    - 할당된 메모리는 힙(Heap) 영역에 존재
    - `new`는 메모리 할당 후 해당 메모리의 주소를 반환.
    - `delete`로 할당된 메모리를 해제할 때 사용
    ```CPP
    int* ptr = new int;  // int형 메모리 할당
    *ptr = 10;  // 값 저장
    delete ptr; // 메모리 해제

    int* arr = new int[5];  // 정수형 배열 5개 동적 할당
    delete[] arr;  // 배열 해제 (배열일 경우 delete 뒤에 `[]` 필요)

    ```
    
- 참조자(Reference)
    - 할당된 메모리 공간(변수)에 별명을 붙이는 것
    - `&`연산자 사용
        - 선언된 변수의 앞: **주소 연산자**
        - 새로 선언되는 변수 앞: **참조자 선언**
    - 선언 가능 범위
        - 여러 개의 참조자 선언 가능
        - 참조자를 대상으로 참조자 선언 가능
        - 변수에 대해서만 선언 가능 (포인터 변수도 o)
        - 선언과 동시에 변수를 참조해야 함
        - NULL 초기화 불가
        - 참조의 대상 바꿀 수 없음
    - call-by-reference
        - 주소 값이용 call-by-reference
        - 참조자 이용 call-by-reference
        - 함수 내에서 참조자를 통한 값의 변경 진행하지 않을 경우, `const` 선언 해주기
    
    - reference 함수
        - 반환형이 참조형인 경우
        ```C
        int num2 = RefRetFuncOne(num1); ✅
        int &num2 = RefRetFuncOne(num1); ✅
        ```
        - 반환형이 기본자료형인 경우
        ```C
        int num2 = RefRetFuncOne(num1); ✅
        int &num2 = RefRetFuncOne(num1); ⛔
        ```
        - 단점  

            ✔ 함수의 정의형태와 함수의 호출형태를 봐도 값의 변경유무를 알 수 없다. 함수의 몸체 형태를 확인해야됨.  

            ✔ c 언어에서는 함수의 호출형태만 보고 알 수 있었음  

            ✔ 단점을 보완하고자 **const 참조자**를 사용
        - ⚠ 주의 ⚠ 지역변수를 참조로 반환하면 **절대 안됨** (컴파일 에러 없음)
    - const 참조자
        `void Func(const int &ref) {. . . }`
        함수 Func 내에서 참조자 ref로 값의 참조는 가능하지만 값의 변경은 허용하지 않겠다는 의미  
        `int &num = 10`
        const 를 붙이면 변수뿐만 아니라 상수도 참조 가능하다 (임시변수)
        - 함수의 원형 선언만 봐도 값의 변경이 일어나지 않음을 판단 가능
        - 실수로 인한 값의 변경이 일어나지 않음
        - 상수 매개변수를 받을 수 있음

- 구조체  
    - 여러 개의 변수를 하나로 묶어 관리할 수 있는 **사용자 정의 자료형**  
    - 클래스와 거의 동일하지만 기본 접근 지정자 **public**
    - C와는 달리 **멤버 함수**를 가질 수 있음


- Question    
    - [Q1. void SwapRef(int &ref1, int &ref2) 선언만 했는데?](Question.md/#q1-void-swaprefint-ref1-int-ref2-선언만-했는데)

## 2일차
- 문자열 총정리 [파일](./Day02/cp00_string.cpp)
- 클래스
    - 객체 지향 프로그래밍에서 객체를 정의하는 틀(템플릿)
    - 멤버 변수와 멤버 함수를 하나로 묶어 관리
    - 객체: 클래스의 인스턴스
    ```cpp
    class MyClass {
    private:                    // 접근 지정자(기본값) 
        int num;                // 멤버 변수
    public:                     // 접근 지정자
        void printVal() {...}   // 멤버 함수
    }
    ```
- 클래스 실습   

    [1️⃣클래스 생성, getter, setter 메소드 만들기](./Day02/p01_myclass.cpp)  

    [2️⃣생성자를 이용해 값 초기화하기](./Day02/p02_myclass2.cpp)  

    [3️⃣문자열 동적할당 받기](./Day02/p03_myclass3.cpp)  

    [4️⃣소멸자를 이용해 메모리 반환하기](./Day02/p04_myclass4.cpp)  

- 생성자
    - 클래스의 이름과 동일한 이름의 **함수**이면서 **반환형이 없는** 함수
    - 함수의 일종이므로, 오버로딩 가능, 디폴트 값 설정 가능
    - 객체 생성 시 자동으로 호출되며, 딱 한번 호출
    - 종류
        - 기본 생성자 - 매개변수가 없는 생성자, 객체를 생성할 때 특별한 초기값 전달 없어도 자동으로 호출
        - 복사 생성자 - 같은 타입의 객체를 받아 새로운 객체를 복사하여 생성하는 생성자
        - 변환 생성자 - 다른 타입의 값을 받아 해당 클래스로 변환하여 객체를 생성하는 생성자
        - 이동 생성자 - 임시 객체(R-value)를 받아 리소스를 효율적으로 이전하여 새로운 객체를 생성하는 생성자 
- 소멸자
    - 객체가 소멸될 때 자동으로 호출되는 함수
    - `~클래스이름()` 

- 접근 지정자
    - private: 클래스 내부에서만 접근 가능(기본값)
    - public: 어디서든 접근 가능
    - protected: 상속받은 클래스에서 접근 가능

- 클래스, 생성자 실습
    - [Human 클래스 만들기](./Day02/p05_human.cpp)

## 3일차
- 생성자
    - 기본 생성자
    - 복사 생성자
    - 변환 생성자
    - 이동 생성자
- 기본 생성자
    - 매개변수가 없으며, 객체를 새로 만들 때 호출
    - `Person p1;`을 하면 `Person()`이 자동 호출됨.
- 복사 생성자
    - 기존 객체를 복사해서 새로운 객체를 만들 때 호출되는 생성자
    - 복사 생성자를 정의하지 않을 경우, 컴파일러가 자동으로 기본 복사 생성자 제공  
        → 단순 **얕은 복사(Shallow Copy)** 만 수행  

        → 깊은 복사가 필요할 경우 따로 복사 생성자를 만들어 주어야 한다 
    -  일반적으로 `const &` 사용

    - 호출 경우
    1. 객체를 다른 객체로 초기화할 때
    2. 객체를 함수 인자로 전달할 때 (값 전달)
    3. 함수에서 객체를 반환할 때(값 반환)


- 변환 생성자 (Conversion Constructor)  
    - 특정 타입의 값을 객체로 변환할 때 호출되는 생성자  
    - 명시적으로 정의하지 않아도 자동으로 만들어질 수 있음  
    - 매개변수가 **하나**인 생성자  
    - `explicit` 키워드를 사용해 암시적 변환을 방지할 수 있음
    - **활용 사례**  
        1. 기본 데이터 타입 → 클래스 객체 변환
        2. 클래스 타입을 다른 클래스로 변환
        3. 함수 매개변수 전달 시 자동 변환  
        4. 연산자 오버로딩과 함께 사용 (`객체 + int` 같은 연산 가능) 

- 이동 생성자 (Move Constructor)
    - 객체를 더 효율적으로 이동할 수 있도록 도와주는 생성자

<!-- - Question    
    - 이후 내용 내일 추가.. 너무 피곤해....
    - [Q2. 복사 생성자에 왜 const & 를 써야하나?](Question.md/#q1-void-swaprefint-ref1-int-ref2-선언만-했는데)  -->